# EIP-7702 Integration with Candide AbstractionKit

This document outlines the steps to integrate EIP-7702 functionality into the Foundry Dashboard, enabling gasless transactions via Candide's infrastructure (specifically their `Simple7702Account`, Bundler, and Paymaster on Sepolia).

## 1. Introduction

The goal is to allow users to opt-in to an EIP-7702 mode. When enabled, transactions (initially, only function calls, not contract creations) will be routed through Candide's ERC-4337 infrastructure. This involves:
1.  The user's EOA (External Owned Account, e.g., MetaMask) authorizing Candide's `Simple7702Account` (a smart contract account) to act on its behalf for specific contract interactions. This is the EIP-7702 "upgrade" or "code designation" step.
2.  The `Simple7702Account` then executing the desired transaction as an ERC-4337 UserOperation.
3.  Candide's Paymaster sponsoring the gas fees for this UserOperation on Sepolia.

This provides a "gasless" experience for the end-user for supported transactions.

## 2. Prerequisites

*   **Foundry Dashboard:** Existing codebase.
*   **Node.js & npm/yarn:** For managing dependencies.
*   **Browser Wallet:** MetaMask or similar, with EIP-7702 support (latest versions usually have this).
*   **Candide Account:** Access to the Candide Dashboard (dashboard.candide.dev) to obtain API URLs/keys for their Sepolia Bundler and Paymaster.
*   **Understanding:**
    *   React, TypeScript, `viem`, `wagmi`.
    *   Basic concepts of EIP-7702 (authorization, designated code).
    *   Basic concepts of ERC-4337 (UserOperation, Bundler, Paymaster, EntryPoint, Smart Account).
    *   Candide's `abstractionkit` SDK.

## 3. High-Level Flow (for a single transaction in EIP-7702 mode)

1.  User enables "EIP-7702 Mode" in the Foundry Dashboard UI.
2.  A transaction request (`eth_sendTransaction`) arrives from Foundry.
3.  The dashboard frontend (`App.tsx`) intercepts this.
4.  **EIP-7702 Authorization (EOA signs):** The EOA signs an EIP-7702 authorization, allowing Candide's `Simple7702Account` delegatee code to run in the EOA's context. This may involve one signature prompt.
5.  **UserOperation Construction:**
    *   The original transaction is wrapped into a `MetaTransaction`.
    *   Candide's `abstractionkit` is used to build a UserOperation that includes this `MetaTransaction` (from `abstractionkit` types) and the EIP-7702 authorization.
6.  **Paymaster Sponsorship:** The UserOperation is sent to Candide's Paymaster to get sponsorship data.
7.  **UserOperation Signing (EOA signs):** The EOA signs the (potentially sponsored) UserOperation hash, authorizing the `Simple7702Account` to execute it. This may involve a second signature prompt.
8.  **Submission:** The signed UserOperation is sent to Candide's Bundler.
9.  **Tracking:** The dashboard tracks the `userOpHash` until it's included in a block and gets a final `transactionHash`.

## 4. Implementation Steps (Client-side)

These changes will primarily be in `client/src/App.tsx` and related files.

### 4.1. Setup & Configuration

1.  **Add Dependencies:**
    *   In `client/package.json`, add `abstractionkit` and `ethers` (as `abstractionkit` might have it as a peer dependency or use it internally).
        ```json
        "dependencies": {
          // ... other dependencies
          "abstractionkit": "^1.3.0", // Or latest version
          "ethers": "^6.13.1",      // Or latest version compatible with abstractionkit
          // ...
        }
        ```
    *   Run `npm install` in the `client` directory.

2.  **UI Toggle for EIP-7702 Mode:**
    *   In `client/src/App.tsx`, add state for the toggle:
        ```typescript
        const [isEip7702Enabled, setIsEip7702Enabled] = useState(false);
        ```
    *   Add a UI element (e.g., Shadcn `Switch` and `Label` from `components/ui/`) to control this state.
        ```tsx
        // In App.tsx's return statement, before DashboardStatus
        <div className="flex items-center space-x-2 mb-6 p-3 bg-gray-700 rounded-md">
            <Switch
                id="eip7702-toggle"
                checked={isEip7702Enabled}
                onCheckedChange={setIsEip7702Enabled}
                disabled={!isConnected || chainId !== 11155111} // Initially enable only for Sepolia
            />
            <Label htmlFor="eip7702-toggle" className="text-sm font-medium">
                Enable EIP-7702 Gasless Transactions (Sepolia Only)
            </Label>
            {(!isConnected || chainId !== 11155111) && isEip7702Enabled && (
                 <p className="text-xs text-yellow-400 ml-2">Connect to Sepolia to use EIP-7702 mode.</p>
            )}
        </div>
        ```
    *   Ensure you have `Switch` and `Label` components (e.g., from `npx shadcn-ui@latest add switch label`).

3.  **Configuration Constants:**
    *   In `client/src/App.tsx` (or a new `client/src/config.ts`), define constants for Candide URLs and addresses.
        ```typescript
        // At the top of App.tsx or in a config file
        const CANDIDE_SEPOLIA_RPC_URL = "https://ethereum-sepolia-rpc.publicnode.com";
        const CANDIDE_SEPOLIA_BUNDLER_URL = "YOUR_CANDIDE_SEPOLIA_BUNDLER_URL_FROM_DASHBOARD";
        const CANDIDE_SEPOLIA_PAYMASTER_URL = "YOUR_CANDIDE_SEPOLIA_PAYMASTER_URL_FROM_DASHBOARD";
        const CANDIDE_ENTRY_POINT_ADDRESS = "0x0000000071727De22E5E9d8bAF0edAc6f37da032"; // AbstractionKit Simple7702Account default (v0.8.0)
        const SIMPLE7702_DEFAULT_DELEGATEE_ADDRESS = "0xe6Cae83BdE06E4c305530e199D7217f42808555B" as Address; // From AbstractionKit
        ```
    *   **Action:** Replace placeholder URLs with actual URLs/API keys from your Candide Dashboard.

### 4.2. Modifying `handleSignTransaction` in `client/src/App.tsx`

Update the `handleSignTransaction` function to include the EIP-7702 flow.

1.  **Import necessary modules from `abstractionkit` and `viem`:**
    ```typescript
    import { Simple7702Account, UserOperationV8, MetaTransaction, CandidePaymaster } from "abstractionkit";
    import { parseSignature, Hex, Address, //... other viem imports
    } from 'viem';
    // Helper from abstractionkit or replicate its bigintToHex logic if needed for eip7702Auth object
    const bigintToHexAK = (val: bigint): Hex => ('0x' + (val === 0n ? '0' : val.toString(16))) as Hex;
    ```

2.  **Branch Logic:** At the beginning of `handleSignTransaction`, check `isEip7702Enabled`.
    ```typescript
    // Inside handleSignTransaction
    if (isEip7702Enabled && chainId === 11155111) { // Restrict to Sepolia for now
        console.log(`[${requestId}] Starting EIP-7702 flow...`);
        if (payload.method !== 'eth_sendTransaction' || !payload.params?.[0]) {
            throw new Error("EIP-7702 flow currently only supports eth_sendTransaction.");
        }
        const rawTx = payload.params[0] as any;
        const sanitizedTx = sanitizeTransactionRequest(rawTx, requestId); // Existing utility

        // --- EIP-7702 Specific Logic Starts Here ---
    } else {
        // --- Standard Flow (existing logic) ---
    }
    ```

3.  **Contract Creation Check (Defer):**
    *   Inside the EIP-7702 branch, if `!sanitizedTx.to` (it's a contract creation):
        ```typescript
        if (!sanitizedTx.to) {
            console.error(`[${requestId}] Contract creation is not supported in EIP-7702 mode yet.`);
            sendSignResponse(currentWs, requestId, { error: { code: -32000, message: "Contract creation via EIP-7702 is not yet supported. Use a factory or disable EIP-7702 mode." } });
            setPendingSignRequests((prev) => prev.filter((req) => req.requestId !== requestId));
            return;
        }
        ```

4.  **Instantiate `Simple7702Account`:**
    ```typescript
    const smartAccount = new Simple7702Account(
        address, // EOA address
        { entrypointAddress: CANDIDE_ENTRY_POINT_ADDRESS }
    );
    ```

5.  **Prepare `MetaTransaction`:**
    ```typescript
    const metaTx: MetaTransaction = { // Use MetaTransaction from abstractionkit
        to: sanitizedTx.to as Address, // We've ensured 'to' exists
        value: sanitizedTx.value || 0n,
        data: sanitizedTx.data || "0x",
        // operation: Operation.Call, // Optional, defaults to Call if not provided by abstractionkit's Simple7702Account
    };
    ```

6.  **Prepare & Sign EIP-7702 Authorization:**
    *   This authorization allows the `SIMPLE7702_DEFAULT_DELEGATEE_ADDRESS` code to run in the context of the EOA.
    *   The `nonce` for `signAuthorization` is the EOA's current transaction count.
    ```typescript
    const eoaNonceForAuth = await publicClient.getTransactionCount({ address, blockTag: 'pending' });
    const designatedContractAddress = SIMPLE7702_DEFAULT_DELEGATEE_ADDRESS;

    console.debug(`Signing EIP-7702 Auth: EOA=${address}, DesignatedContract=${designatedContractAddress}, EOAAuthNonce=${eoaNonceForAuth}`);
    const eip7702FullSignature = await walletClient.signAuthorization({
        account: address,
        contractAddress: designatedContractAddress,
        nonce: eoaNonceForAuth,
        chainId: BigInt(chainId),
        // authority & executor: Use viem defaults unless Simple7702Account requires specifics.
    });

    const { r, s, yParity } = parseSignature(eip7702FullSignature);

    const eip7702AuthForUserOpOverride = { // Matches Authorization7702Hex structure from abstractionkit
        chainId: bigintToHexAK(BigInt(chainId)),
        address: address,
        nonce: bigintToHexAK(eoaNonceForAuth),
        yParity: yParity === 0n ? '0x00' : '0x01', // Ensure '0x00' or '0x01'
        r: r as Hex,
        s: s as Hex,
    };
    console.debug({ authData: eip7702AuthForUserOpOverride }, "Prepared EIP-7702 Auth data for UserOp override");
    ```

7.  **Create UserOperation (using `abstractionkit`):**
    ```typescript
    console.debug("Creating UserOperation with abstractionkit...");
    let userOperation = await smartAccount.createUserOperation(
        [metaTx],
        CANDIDE_SEPOLIA_RPC_URL,
        CANDIDE_SEPOLIA_BUNDLER_URL,
        { eip7702Auth: eip7702AuthForUserOpOverride }
    ) as UserOperationV8; // Cast to specific version if known, e.g., UserOperationV8
    console.debug({ userOp: userOperation }, "UserOperation created by abstractionkit");
    ```

8.  **Paymaster Sponsorship (using `abstractionkit`):**
    ```typescript
    console.debug("Applying paymaster sponsorship...");
    const paymaster = new CandidePaymaster(CANDIDE_SEPOLIA_PAYMASTER_URL);
    const [paymasterUserOperation, sponsorMetadata] = await paymaster.createSponsorPaymasterUserOperation(
        userOperation,
        CANDIDE_SEPOLIA_BUNDLER_URL,
    );
    userOperation = paymasterUserOperation as UserOperationV8;
    console.debug({ userOp: userOperation, sponsorMeta: sponsorMetadata }, "UserOperation after paymaster");
    ```

9.  **Sign UserOperation (for `Simple7702Account`):**
    ```typescript
    console.debug("Getting UserOperation hash...");
    const userOpHash = await smartAccount.getUserOperationHash(
        userOperation,
        CANDIDE_ENTRY_POINT_ADDRESS, // Ensure this matches the entrypoint Simple7702Account uses
        BigInt(chainId)
    );
    console.debug(`UserOperation hash to sign: ${userOpHash}`);

    console.debug("Signing UserOperation hash with walletClient...");
    const userOpSignature = await walletClient.signMessage({
        account: address,
        message: { raw: userOpHash as Hex }, // message can be string or { raw: Hex }
    });
    userOperation.signature = userOpSignature;
    console.debug(`UserOperation signature: ${userOpSignature}`);
    ```

10. **Send UserOperation (using `abstractionkit`):**
    ```typescript
    console.debug("Sending UserOperation to bundler...");
    const sendUserOpResponse = await smartAccount.sendUserOperation(userOperation, CANDIDE_SEPOLIA_BUNDLER_URL);
    console.info(`UserOperation sent. UserOpHash: ${sendUserOpResponse.userOperationHash}`);
    result = sendUserOpResponse.userOperationHash; // Store UserOpHash as the initial result
    ```

11. **Common Success Handling (after EIP-7702 or Standard flow):**
    *   The existing logic that adds to `trackedTxs` and calls `sendSignResponse` will use the `result` (which is now `userOpHash` for EIP-7702 flow).
    *   Modify the `label` generation for `TrackedTxInfo` to indicate EIP-7702.
        ```typescript
        // Inside the success block of handleSignTransaction, after 'result' is set
        const txLabel = isEip7702Enabled && chainId === 11155111
            ? `EIP-7702: ${generateTxLabel(request.payload.decoded)} (UserOp)`
            : generateTxLabel(request.payload.decoded);

        const newTrackedTx: TrackedTxInfo = {
            hash: result as Hex, // This is UserOpHash for EIP-7702, TxHash for standard
            // ... other fields ...
            label: txLabel,
        };
        setTrackedTxs(prevMap => new Map(prevMap).set(newTrackedTx.hash, newTrackedTx));
        ```

### 4.3. Transaction Tracking & UI Updates for UserOperations

1.  **Update `TrackedTxInfo` (in `client/src/types.ts`):**
    *   Add an optional `actualTxHash?: Hex;` field.
    *   Add an optional `userOpHash?: Hex;` field (or decide if `hash` field will store UserOpHash initially). For clarity, let's assume `hash` stores UserOpHash initially for EIP-7702, and `actualTxHash` is filled later.

2.  **Update `TrackedTransactionsList.tsx`:**
    *   When generating explorer links, if `tx.actualTxHash` exists, use it. Otherwise, use `tx.hash`.
    *   Display both `userOpHash` (if `tx.hash` is it) and `actualTxHash` if available.

3.  **Asynchronously Update Tracking with Inclusion Result:**
    *   After `sendUserOpResponse`, start polling for the UserOperation receipt using `sendUserOpResponse.included()`.
    ```typescript
    // Inside EIP-7702 block, after sendUserOpResponse
    sendUserOpResponse.included()
        .then(receiptResult => {
            console.info(`UserOperation included. TxHash: ${receiptResult.receipt?.transactionHash}`);
            setTrackedTxs(prevMap => {
                const userOpHashToUpdate = sendUserOpResponse.userOperationHash as Hex;
                const existing = prevMap.get(userOpHashToUpdate);
                if (existing) {
                    const updatedTxInfo: TrackedTxInfo = {
                        ...existing,
                        status: receiptResult.success ? 'success' : 'reverted',
                        blockNumber: receiptResult.receipt?.blockNumber,
                        actualTxHash: receiptResult.receipt?.transactionHash as Hex || undefined,
                        // contractAddress: // May need parsing from logs for UserOps
                    };
                    // Option 1: Update existing entry (keyed by UserOpHash)
                    return new Map(prevMap).set(userOpHashToUpdate, updatedTxInfo);
                    // Option 2: If you want to re-key by actualTxHash (more complex UI updates)
                    // const newMap = new Map(prevMap);
                    // newMap.delete(userOpHashToUpdate);
                    // if (updatedTxInfo.actualTxHash) newMap.set(updatedTxInfo.actualTxHash, updatedTxInfo);
                    // else newMap.set(userOpHashToUpdate, updatedTxInfo); // Fallback
                    // return newMap;
                }
                return prevMap;
            });
        })
        .catch(inclusionError => {
            console.error({ err: inclusionError }, "Error waiting for UserOperation inclusion");
            setTrackedTxs(prevMap => { // Mark as reverted on inclusion error
                const userOpHashToUpdate = sendUserOpResponse.userOperationHash as Hex;
                const existing = prevMap.get(userOpHashToUpdate);
                if (existing) {
                    return new Map(prevMap).set(userOpHashToUpdate, { ...existing, status: 'reverted' });
                }
                return prevMap;
            });
        });
    ```

### 4.4. Error Handling & UX

*   Wrap the entire EIP-7702 specific logic within `handleSignTransaction` in its own `try...catch` block to provide more specific error messages for EIP-7702 failures.
*   **UX for Multiple Signatures:** Be prepared for two signature prompts from MetaMask for the first EIP-7702 transaction (one for `signAuthorization`, one for `signMessage` for the UserOp). Subsequent transactions for the same EOA *might* not need the `signAuthorization` step if the authorization is persistent for the session or chain. (This persistence needs to be investigated for EIP-7702).

## 5. Key Considerations / Challenges

*   **EIP-7702 Wallet Support:** Ensure target wallets (MetaMask) fully support `signAuthorization`.
*   **`abstractionkit` API for Browser Wallets:**
    *   Confirm the exact structure of the `eip7702Auth` object expected by `smartAccount.createUserOperation` when providing a pre-signed authorization.
    *   Confirm if `Simple7702Account` expects `eth_sign` (via `signMessage({ raw: hash })`) or EIP-712 signatures for UserOperations. The current plan assumes `eth_sign`.
*   **Contract Creation:** Deferred for now. Requires a factory pattern.
*   **UserOperation Receipt Details:** Extracting deployed contract addresses from UserOperation receipts can be complex as it might involve parsing logs from the EntryPoint contract.
*   **EIP-7702 Authorization Persistence:** How long does the `signAuthorization` grant last? Is it per session, per transaction, or until revoked? This affects whether the `signAuthorization` step is always needed. EIP-7702 states authorizations are active until a new one for the same `(contractAddress, authority)` is set, or the EOA's code is changed by other means. This implies it's persistent. The dashboard might need to track if an authorization has already been successfully submitted for the current EOA and `SIMPLE7702_DEFAULT_DELEGATEE_ADDRESS`.

This detailed plan should provide a good roadmap. The most critical parts will be correctly interfacing with `abstractionkit` for the EIP-7702 authorization object and ensuring the UserOperation signing is compatible with `Simple7702Account`.
